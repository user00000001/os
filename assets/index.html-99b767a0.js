import{_ as t,M as i,p as o,q as r,R as e,t as a,N as d,a1 as s}from"./framework-5866ffd3.js";const l={},c=s(`<h1 id="操作系统" tabindex="-1"><a class="header-anchor" href="#操作系统" aria-hidden="true">#</a> 操作系统</h1><h2 id="系统安装" tabindex="-1"><a class="header-anchor" href="#系统安装" aria-hidden="true">#</a> 系统安装</h2><h3 id="_0-刻录到光盘或者u盘启动-解决绝大部分系统安装问题" tabindex="-1"><a class="header-anchor" href="#_0-刻录到光盘或者u盘启动-解决绝大部分系统安装问题" aria-hidden="true">#</a> 0. 刻录到光盘或者U盘启动，解决绝大部分系统安装问题</h3><h3 id="_1-uefi硬盘通用安装" tabindex="-1"><a class="header-anchor" href="#_1-uefi硬盘通用安装" aria-hidden="true">#</a> 1. UEFI硬盘通用安装</h3><h4 id="找到一块分区并格式化成fat32-将系统iso文件解压到该分区-重新启动-然后在启动项里选择新出现的项目-进入安装流程-期间可能需要easyuefi等指定启动efi文件-此方式可以安装ubuntu、windows等操作系统" tabindex="-1"><a class="header-anchor" href="#找到一块分区并格式化成fat32-将系统iso文件解压到该分区-重新启动-然后在启动项里选择新出现的项目-进入安装流程-期间可能需要easyuefi等指定启动efi文件-此方式可以安装ubuntu、windows等操作系统" aria-hidden="true">#</a> 找到一块分区并格式化成FAT32，将系统ISO文件解压到该分区，重新启动，然后在启动项里选择新出现的项目，进入安装流程，期间可能需要easyuefi等指定启动efi文件，此方式可以安装ubuntu、Windows等操作系统</h4><h3 id="_2-deepin-uefi安装" tabindex="-1"><a class="header-anchor" href="#_2-deepin-uefi安装" aria-hidden="true">#</a> 2. Deepin uefi安装</h3><h4 id="若有grub启动-则直接在-boot-grub-grub-cfg内添加启动信息如下" tabindex="-1"><a class="header-anchor" href="#若有grub启动-则直接在-boot-grub-grub-cfg内添加启动信息如下" aria-hidden="true">#</a> 若有grub启动，则直接在/boot/grub/grub.cfg内添加启动信息如下</h4><div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token builtin class-name">set</span> <span class="token assign-left variable">timeout</span><span class="token operator">=</span><span class="token number">3</span>

insmod part_gpt
insmod ext2
insmod efi_gop
insmod efi_uga
insmod video_bochs
insmod video_cirrus
insmod loopback
insmod part_msdos
insmod fat
insmod ntfs
insmod ntfscomp

menuentry <span class="token string">&#39;deepin install&#39;</span> <span class="token punctuation">{</span>
    search <span class="token parameter variable">--label</span> <span class="token parameter variable">--set</span><span class="token operator">=</span>root DATA
    <span class="token builtin class-name">set</span> <span class="token assign-left variable">isofile</span><span class="token operator">=</span><span class="token string">&quot;/deepin-15.10.1-amd64.iso&quot;</span>
    loopback loop <span class="token variable">$isofile</span>
    linux <span class="token punctuation">(</span>loop<span class="token punctuation">)</span>/live/vmlinuz.efi  <span class="token assign-left variable">boot</span><span class="token operator">=</span>live <span class="token assign-left variable">union</span><span class="token operator">=</span>overlay <span class="token assign-left variable">username</span><span class="token operator">=</span>user quiet  live-config noprompt noeject <span class="token assign-left variable">findiso</span><span class="token operator">=</span><span class="token variable">$isofile</span> <span class="token assign-left variable">locales</span><span class="token operator">=</span>zh_CN.UTF-8
    initrd <span class="token punctuation">(</span>loop<span class="token punctuation">)</span>/live/initrd.lz
<span class="token punctuation">}</span>
</code></pre></div><h4 id="也可进入ubuntu的grub控制台输入以上命令手动引导启动-也适用于kali系统安装" tabindex="-1"><a class="header-anchor" href="#也可进入ubuntu的grub控制台输入以上命令手动引导启动-也适用于kali系统安装" aria-hidden="true">#</a> 也可进入ubuntu的grub控制台输入以上命令手动引导启动，也适用于Kali系统安装</h4><h3 id="_3-kali-linux-rolling-uefi安装" tabindex="-1"><a class="header-anchor" href="#_3-kali-linux-rolling-uefi安装" aria-hidden="true">#</a> 3. Kali linux rolling uefi安装</h3>`,10),p={id:"拿kali-linux-2023-1-installer-everything-amd64-iso为例-每个iso可能有不同的问题-给出一般排查定位流程",tabindex:"-1"},h=e("a",{class:"header-anchor",href:"#拿kali-linux-2023-1-installer-everything-amd64-iso为例-每个iso可能有不同的问题-给出一般排查定位流程","aria-hidden":"true"},"#",-1),u={href:"https://cdimage.kali.org/kali-2023.1/kali-linux-2023.1-installer-everything-amd64.iso.torrent",target:"_blank",rel:"noopener noreferrer"},f=s(`<h4 id="解压到一个合适大小的fat32分区-bios自动检测此分区efi-或easyuefi手动引导-开机进入正常安装流程-遇到问题-ctrl-fx-进入终端操作-从某一个fx可以看到安装日志-再根据日志报错判断" tabindex="-1"><a class="header-anchor" href="#解压到一个合适大小的fat32分区-bios自动检测此分区efi-或easyuefi手动引导-开机进入正常安装流程-遇到问题-ctrl-fx-进入终端操作-从某一个fx可以看到安装日志-再根据日志报错判断" aria-hidden="true">#</a> 解压到一个合适大小的FAT32分区，bios自动检测此分区EFI，或EasyUEFI手动引导，开机进入正常安装流程，遇到问题，CTRL+Fx 进入终端操作，从某一个Fx可以看到安装日志，再根据日志报错判断</h4><h5 id="_1-no-media处理" tabindex="-1"><a class="header-anchor" href="#_1-no-media处理" aria-hidden="true">#</a> 1，No Media处理</h5><div class="language-text" data-ext="text"><pre class="language-text"><code>**********************!!!PROTECTION POLICY!!!**********************
Waiting For The Next Deployment, Maybe It Will Be Displayed After That.
</code></pre></div><h5 id="_2-软件包选择错误处理" tabindex="-1"><a class="header-anchor" href="#_2-软件包选择错误处理" aria-hidden="true">#</a> 2，软件包选择错误处理</h5><div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token function">cp</span> /target/etc/apt/sources.list /target/etc/apt/sources.list.new
</code></pre></div><h2 id="备份移植系统分区" tabindex="-1"><a class="header-anchor" href="#备份移植系统分区" aria-hidden="true">#</a> 备份移植系统分区</h2><h3 id="_1-分区操作" tabindex="-1"><a class="header-anchor" href="#_1-分区操作" aria-hidden="true">#</a> 1. 分区操作</h3><h4 id="使用分区工具gparted-diskgenius等将系统所在分区进行容量缩减-最好保留一定大小的伸缩空间-使用dd将系统分区保留成文件" tabindex="-1"><a class="header-anchor" href="#使用分区工具gparted-diskgenius等将系统所在分区进行容量缩减-最好保留一定大小的伸缩空间-使用dd将系统分区保留成文件" aria-hidden="true">#</a> 使用分区工具gparted/diskgenius等将系统所在分区进行容量缩减，最好保留一定大小的伸缩空间，使用dd将系统分区保留成文件</h4><div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token function">dd</span> <span class="token assign-left variable">if</span><span class="token operator">=</span>/dev/<span class="token operator">&lt;</span>系统分区<span class="token operator">&gt;</span> <span class="token assign-left variable">of</span><span class="token operator">=</span>/media/<span class="token operator">&lt;</span>存储位置<span class="token operator">&gt;</span>/<span class="token operator">&lt;</span>指定文件名<span class="token operator">&gt;</span> <span class="token assign-left variable">status</span><span class="token operator">=</span>progress
</code></pre></div><h4 id="留出待装入系统分区-必须大于系统备份文件大侠-进行磁盘文件写入" tabindex="-1"><a class="header-anchor" href="#留出待装入系统分区-必须大于系统备份文件大侠-进行磁盘文件写入" aria-hidden="true">#</a> 留出待装入系统分区，必须大于系统备份文件大侠，进行磁盘文件写入</h4><div class="language-text" data-ext="text"><pre class="language-text"><code>**********************!!!PROTECTION POLICY!!!**********************
Waiting For The Next Deployment, Maybe It Will Be Displayed After That.
</code></pre></div><h4 id="由于写入系统文件内的分区大小与此时系统分区的大小可能不符-需要对现分区进行缩小再扩展-才能使系统分区回到真实容量" tabindex="-1"><a class="header-anchor" href="#由于写入系统文件内的分区大小与此时系统分区的大小可能不符-需要对现分区进行缩小再扩展-才能使系统分区回到真实容量" aria-hidden="true">#</a> 由于写入系统文件内的分区大小与此时系统分区的大小可能不符，需要对现分区进行缩小再扩展，才能使系统分区回到真实容量</h4><h3 id="_2-linux系统恢复操作" tabindex="-1"><a class="header-anchor" href="#_2-linux系统恢复操作" aria-hidden="true">#</a> 2. linux系统恢复操作</h3><h4 id="进入其他liunx系统-挂载系统分区-若为uefi模式-需要挂载efi分区" tabindex="-1"><a class="header-anchor" href="#进入其他liunx系统-挂载系统分区-若为uefi模式-需要挂载efi分区" aria-hidden="true">#</a> 进入其他liunx系统，挂载系统分区，若为uefi模式，需要挂载efi分区</h4><div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token function">mount</span> /dev/<span class="token operator">&lt;</span>系统分区<span class="token operator">&gt;</span> /mnt
<span class="token function">mount</span> /dev/<span class="token operator">&lt;</span>efi分区<span class="token operator">&gt;</span> /mnt/boot/efi <span class="token comment"># uefi启动模式需要</span>
<span class="token function">mount</span> <span class="token parameter variable">-o</span> <span class="token builtin class-name">bind</span> /dev /mnt/dev/
<span class="token function">mount</span> <span class="token parameter variable">-o</span> <span class="token builtin class-name">bind</span> /proc /mnt/proc/
<span class="token function">mount</span> <span class="token parameter variable">-o</span> <span class="token builtin class-name">bind</span> /sys /mnt/sys/
</code></pre></div><h4 id="修复系统启动grub引导数据-将-etc-fstab挂载信息更新成现系统需要的分区" tabindex="-1"><a class="header-anchor" href="#修复系统启动grub引导数据-将-etc-fstab挂载信息更新成现系统需要的分区" aria-hidden="true">#</a> 修复系统启动grub引导数据，将/etc/fstab挂载信息更新成现系统需要的分区</h4><div class="language-text" data-ext="text"><pre class="language-text"><code>**********************!!!PROTECTION POLICY!!!**********************
Waiting For The Next Deployment, Maybe It Will Be Displayed After That.
</code></pre></div><h4 id="大体修复完成-细节进入系统再调整" tabindex="-1"><a class="header-anchor" href="#大体修复完成-细节进入系统再调整" aria-hidden="true">#</a> 大体修复完成，细节进入系统再调整</h4><h3 id="_3-windows系统恢复操作" tabindex="-1"><a class="header-anchor" href="#_3-windows系统恢复操作" aria-hidden="true">#</a> 3. Windows系统恢复操作</h3><h4 id="windows直接进入-会在用户登录界面-界面反复重启-快捷键进入从任务管理器-再运行cmd后发现不是默认c盘-需要对备份前的盘符映射表进行清除或修改" tabindex="-1"><a class="header-anchor" href="#windows直接进入-会在用户登录界面-界面反复重启-快捷键进入从任务管理器-再运行cmd后发现不是默认c盘-需要对备份前的盘符映射表进行清除或修改" aria-hidden="true">#</a> Windows直接进入，会在用户登录界面，界面反复重启，快捷键进入从任务管理器，再运行cmd后发现不是默认C盘，需要对备份前的盘符映射表进行清除或修改</h4><div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 进入PE或其他Windows系统，打开regedit注册表编辑器，默认为PE或现系统的注册表。点击注册表左侧栏任一项，再菜单内File-&gt;Load Hive，找到需要修复引导的系统分区，选择Windows\\System32\\config\\SYSTEM路径文件，保存为任意名，进入新命名项，删除MountedDevices目录项或者进入更新系统分区参数信息，操作完成后退出regedit</span>

<span class="token comment"># 大体修复完成，细节进入系统再调整，可能需要在PE内修复引导</span>
</code></pre></div><h3 id="_4-启动顺序调整" tabindex="-1"><a class="header-anchor" href="#_4-启动顺序调整" aria-hidden="true">#</a> 4. 启动顺序调整</h3><div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># bios调整，根据主板情况，大体位置在boot项</span>

<span class="token comment"># 软件调整，linux下grub配置、efibootmgr命令，Windows下easybcd、easyuefi软件、bcdedit命令</span>
</code></pre></div><h3 id="_5-mac系统分区移动恢复" tabindex="-1"><a class="header-anchor" href="#_5-mac系统分区移动恢复" aria-hidden="true">#</a> 5. Mac系统分区移动恢复</h3><div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 先进入mac系统，使用带界面分区工具diskutil，在系统分区上点击分区，再点击分区扇面，在右侧调整系统分区容量数值，要大于实际已使用容量</span>

<span class="token comment"># 再进入Linux内dd备份分区，并dd将备份文件恢复到指定的分区上，进入powershell或diskgenius或fdisk内将分区改成指定的mac系统分区相应的分区类型编号</span>

<span class="token comment"># 启动mac分区，将现有分区实际容量，按照前面的分区操作，追加到系统分区上</span>
</code></pre></div>`,25);function b(g,k){const n=i("ExternalLinkIcon");return o(),r("div",null,[c,e("h4",p,[h,a(" 拿"),e("a",u,[a("kali-linux-2023.1-installer-everything-amd64.iso"),d(n)]),a("为例，每个iso可能有不同的问题，给出一般排查定位流程")]),f])}const x=t(l,[["render",b],["__file","index.html.vue"]]);export{x as default};
